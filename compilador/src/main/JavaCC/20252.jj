options {
  IGNORE_CASE = true;
  STATIC = false;
}

PARSER_BEGIN(Linguagem20252)

import org.example.Linguagem20252Constants;
import java.util.*;
import java.io.*;

public class Linguagem20252 {
    public static final List<String> parseErrors = new ArrayList<>();

    public static void clearParseErrors() {
        parseErrors.clear();
    }

    public static void printParseErrors() {
        if (parseErrors.isEmpty()) return;
        System.err.println("Erros sintáticos encontrados:");
        for (String msg : parseErrors) {
            System.err.println("  - " + msg);
        }
    }

    void reportParseError(ParseException e) {
        Token tok = e.currentToken.next;
        String found = (tok == null) ? "EOF" : tok.image;
        int line = (tok == null) ? -1 : tok.beginLine;
        int col  = (tok == null) ? -1 : tok.beginColumn;

        StringBuilder expected = new StringBuilder();
        if (e.expectedTokenSequences != null) {
            for (int i = 0; i < e.expectedTokenSequences.length; i++) {
                int[] seq = e.expectedTokenSequences[i];
                if (i > 0) expected.append(" | ");
                for (int j = 0; j < seq.length; j++) {
                    expected.append(Linguagem20252Constants.tokenImage[seq[j]]).append(" ");
                }
            }
        } else {
            expected.append("token válido");
        }

        String msg = "Erro sintático na linha " + line + ", coluna " + col +
                     ": encontrado '" + found + "'. Esperado: " + expected.toString();
        Linguagem20252.parseErrors.add(msg);
        System.err.println(msg);
    }

    public static void main(String[] args) {
        try {
            clearParseErrors();
            Linguagem20252 parser = new Linguagem20252(System.in);
            parser.programa();

            if (parseErrors.isEmpty()) {
                System.out.println("Programa compilado com sucesso.");
            } else {
                System.out.println("Análise concluída com erros sintáticos:");
                printParseErrors();
            }

        } catch (ParseException e) {
            System.err.println("Erro fatal: " + e.getMessage());
        } catch (TokenMgrError tme) {
            System.err.println("Erro léxico: " + tme.getMessage());
        } catch (Exception ex) {
            System.err.println("Erro inesperado: " + ex.getMessage());
            ex.printStackTrace(System.err);
        }
    }
}

PARSER_END(Linguagem20252)

// ---------------------- TOKENS ------------------------

TOKEN :
{
  // Palavras Reservadas
  < BEGIN: "begin" >
| < DEFINE: "define" >
| < START: "start" >
| < END: "end" >
| < NUM: "num" >
| < REAL: "real" >
| < TEXT: "text" >
| < FLAG: "flag" >
| < SET: "set" >
| < READ: "read" >
| < SHOW: "show" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < TRUE: "true" >
| < FALSE: "false" >
| < LOOP: "loop" >
| < WHILE: "while" >

  // Símbolos Especiais
| < ATRIBUICAO: "=" >
| < PONTO: "." >
| < DOIS_PONTOS: ":" >
| < PONTO_E_VIRGULA: ";" >
| < VIRGULA: "," >
| < ABRE_PARENTESES: "(" >
| < FECHA_PARENTESES: ")" >
| < ABRE_COLCHETES: "[" >
| < FECHA_COLCHETES: "]" >
| < ABRE_CHAVES: "{" >
| < FECHA_CHAVES: "}" >
| < MAIS: "+" >
| < MENOS: "-" >
| < VEZES: "*" >
| < DIVIDIR: "/" >
| < POTENCIA: "**" >
| < DIVISAO_INTEIRA: "%" >
| < RESTO_DIVISAO: "%%" >
| < IGUAL: "==" >
| < DIFERENTE: "!=" >
| < MENOR_OU_IGUAL: "<<=" >
| < MAIOR_OU_IGUAL: ">>=" >
| < MENOR: "<<" >
| < MAIOR: ">>" >
| < E: "&" >
| < OU: "|" >
| < NAO: "!" >

  // Identificadores e Constantes
| < IDENTIFICADOR: ( <LETRA> | "_" ) ( <LETRA> | <DIGITO> | "_" )* >
| < CONSTANTE_INTEIRA: (<DIGITO>)+ >
| < CONSTANTE_REAL: (<DIGITO>)+ "." (<DIGITO>)+ >
| < CONSTANTE_LITERAL:
        "\"" (~["\"","\n","\r"])* "\""
      | "'"  (~["'","\n","\r"])* "'"
  >
| < CONSTANTE_LOGICA: ( "true" | "false" ) >

  // Tokens auxiliares
| < #LETRA: [ "A"-"Z", "a"-"z" ] >
| < #DIGITO: [ "0"-"9" ] >
| < #ASCII: ~["\u0000" - "\u001F", "\u007F"] >
}

SKIP :
{
  < ESPACO_BRANCO: ( " " | "\t" | "\n" | "\r" )+ >
| < COMENTARIO_LINHA: ("//"(<ASCII>)*) >
| < COMENTARIO_BLOCO: ("/*"(<ASCII> | "\n")* "*/") >
}

// ---------------------- ERROS LÉXICOS ------------------------

TOKEN :{
  < CONST_INT_INVALIDA: (<DIGITO><DIGITO><DIGITO>(<DIGITO>)+)>
| < CONST_REAL_INVALIDA:
      (<DIGITO>)+ "." (<DIGITO>)* ("." (<DIGITO>)+)+ >
| < IDENTIFICADOR_INVALIDO:
      ( <DIGITO> ( <LETRA> | <DIGITO> | "_" )* ) >
| < COMENTARIO_NAO_FECHADO: "/*" (~[])* >
| < LITERAL_NAO_FECHADO:
          "\"" (~["\"","\n","\r"])* ("\n" | "\r" | "\r\n")
        | "'"  (~["'","\n","\r"])* ("\n" | "\r" | "\r\n")
    >
| < SIMBOLO_INVALIDO: ~[] >
}

// ---------------------- SINTÁTICO ------------------------

void programa() :{}
{
  <BEGIN> opcional_id() opcional_def() <START> lista_de_comandos() <END> <PONTO> <EOF>
}

void opcional_id() :{}
{ (<IDENTIFICADOR>)? }

void opcional_def() :{}
{ (<DEFINE> lista_declaracao_var())? }

void tipo():{}
{ <NUM> | <REAL> | <TEXT> | <FLAG> }

void valor(): {}
{ <CONSTANTE_INTEIRA> | <CONSTANTE_REAL> | <CONSTANTE_LITERAL> }

void declaracao_de_variaveis():{}
{ lista_de_identificadores() <DOIS_PONTOS> tipo() declaracao_de_variaveis_aux() }

void declaracao_de_variaveis_aux():{}
{
    <ATRIBUICAO> valor() <PONTO_E_VIRGULA>
  | <ABRE_COLCHETES> <CONSTANTE_INTEIRA> <FECHA_COLCHETES> declaracao_de_variaveis_aux2()
  | <PONTO_E_VIRGULA>
}

void declaracao_de_variaveis_aux2():{}
{ (<ATRIBUICAO> <ABRE_CHAVES> valores() <FECHA_CHAVES> <PONTO_E_VIRGULA>)? }

void lista_declaracao_var():{}
{
  try {
    declaracao_de_variaveis() (lista_declaracao_var_aux())?
  } catch (ParseException e) {
    reportParseError(e);
    skipUntil(new int[]{PONTO_E_VIRGULA, START});
    if (getToken(1).kind == PONTO_E_VIRGULA) getNextToken();
  }
}

void lista_declaracao_var_aux():{}
{ lista_declaracao_var() }

void lista_de_identificadores():{}
{ <IDENTIFICADOR> lista_de_identificadores_aux() }

void lista_de_identificadores_aux():{}
{ (<VIRGULA> lista_de_identificadores())? }

void valores(): {}
{ valor() valores_aux() }

void valores_aux(): {}
{ (<VIRGULA> valores())? }

// ---------------------- COMANDOS ------------------------

void lista_de_comandos():{}
{
  {
    while (true) {
      Token la = getToken(1);
      if (la == null) break;
      if (la.kind == END || la.kind == PONTO || la.kind == FECHA_CHAVES)
        break;

      try {
        comando();
      } catch (ParseException e) {
        reportParseError(e);
        skipUntil(new int[]{PONTO_E_VIRGULA, END, PONTO, FECHA_CHAVES});
        Token t = getToken(1);
        if (t != null && t.kind == PONTO_E_VIRGULA) getNextToken();
      }
    }
  }
}

void comando():{}
{
  try {
    comando_atribuicao()
  | comando_saida_dados()
  | comando_repeticao()
  | comando_selecao()
  | comando_entrada_dados()
  } catch (ParseException e) {
    reportParseError(e);
    skipUntil(new int[]{PONTO_E_VIRGULA, END});
    if (getToken(1).kind == PONTO_E_VIRGULA) getNextToken();
  }
}

void comando_atribuicao():{}
{ <SET> <IDENTIFICADOR> comando_atribuicao_aux() }

void comando_atribuicao_aux():{}
{
  (<ATRIBUICAO> expressao() <PONTO_E_VIRGULA>)
| (<ABRE_COLCHETES> <CONSTANTE_INTEIRA> <FECHA_COLCHETES> <ATRIBUICAO> expressao() <PONTO_E_VIRGULA>)
}

void comando_entrada_dados():{}
{ <READ> <ABRE_PARENTESES> <IDENTIFICADOR> cmd_dados() }

void cmd_dados():{}
{
  <FECHA_PARENTESES> <PONTO_E_VIRGULA>
| <ABRE_COLCHETES> <CONSTANTE_INTEIRA> <FECHA_COLCHETES> <FECHA_PARENTESES> <PONTO_E_VIRGULA>
}

void comando_saida_dados():{}
{ <SHOW> <ABRE_PARENTESES> lista_id_const() <FECHA_PARENTESES> <PONTO_E_VIRGULA> }

void lista_id_const():{}
{ valor() lista() | <IDENTIFICADOR> lista() }

void lista():{}
{ (<VIRGULA> lista_id_const())? }

void comando_selecao():{}
{
  try {
    <IF> expressao() <THEN> lista_de_comandos() cmd_else() <END> <PONTO_E_VIRGULA>
  } catch (ParseException e) {
    reportParseError(e);
    skipUntil(new int[]{PONTO_E_VIRGULA, END, ELSE});
    if (getToken(1).kind == PONTO_E_VIRGULA) getNextToken();
  }
}

void cmd_else():{}
{ (<ELSE> lista_de_comandos())? }

void comando_repeticao():{}
{
  try {
    <LOOP> <WHILE> expressao() lista_de_comandos() <END> <PONTO_E_VIRGULA>
  } catch (ParseException e) {
    reportParseError(e);
    skipUntil(new int[]{PONTO_E_VIRGULA, END});
    if (getToken(1).kind == PONTO_E_VIRGULA) getNextToken();
  }
}

// ---------------------- EXPRESSÕES ------------------------

void expressao() :{}
{ expressao_aux() }

void expressao_aux() :{}
{
  expressao_arit()
  ( ( <IGUAL> | <DIFERENTE> | <MENOR> | <MAIOR> | <MENOR_OU_IGUAL> | <MAIOR_OU_IGUAL> ) expressao_arit() )?
}

void expressao_arit() :{}
{ termo2() menor_prioridade() }

void menor_prioridade() :{}
{ ( ( <MAIS> | <MENOS> | <OU> ) termo2() )* }

void termo2() :{}
{ termo1() media_prioridade() }

void media_prioridade() :{}
{ ( ( <VEZES> | <DIVIDIR> | <DIVISAO_INTEIRA> | <RESTO_DIVISAO> | <E> ) termo1() )* }

void termo1() :{}
{ elemento() ( <POTENCIA> elemento() )* }

void elemento() :{}
{
  <IDENTIFICADOR>
| <CONSTANTE_INTEIRA>
| <CONSTANTE_REAL>
| <CONSTANTE_LITERAL>
| <CONSTANTE_LOGICA>
| <ABRE_PARENTESES> expressao() <FECHA_PARENTESES>
| <NAO> <ABRE_PARENTESES> expressao() <FECHA_PARENTESES>
}

// ---------------------- RECUPERAÇÃO DE ERROS ------------------------

void skipUntil(int[] syncTokens) :
{ Token t; }
{
  {
    while (true) {
      t = getToken(1);
      if (t == null || t.kind == 0) return;
      boolean ok = false;
      for (int i=0; i<syncTokens.length; i++) {
        if (t.kind == syncTokens[i]) { ok = true; break; }
      }
      if (ok) return;
      getNextToken();
    }
  }
}


