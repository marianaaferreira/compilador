options {
  IGNORE_CASE = true;
  STATIC = false;
}

PARSER_BEGIN(Linguagem20252)

import java.util.*;
import java.io.*;
import org.example.Semantico;

public class Linguagem20252 {

    public static final List<String> parseErrors = new ArrayList<>();
    public static final List<String> lexicalErrors = new ArrayList<>();

    public static void clearParseErrors() {
        parseErrors.clear();
        lexicalErrors.clear();
    }

    public static void printParseErrors() {
        for (String msg : parseErrors) {
            System.out.println(msg);
        }
    }

    void reportParseError(ParseException e) {
            Token tok = e.currentToken.next;
            String found = (tok == null) ? "EOF" : tok.image;
            int line = (tok == null) ? -1 : tok.beginLine;
            int col  = (tok == null) ? -1 : tok.beginColumn;

            StringBuilder expected = new StringBuilder();
            if (e.expectedTokenSequences != null) {
                for (int i = 0; i < e.expectedTokenSequences.length; i++) {
                    int[] seq = e.expectedTokenSequences[i];
                    if (i > 0) expected.append(" | ");
                    for (int j = 0; j < seq.length; j++) {
                        expected.append(Linguagem20252Constants.tokenImage[seq[j]]).append(" ");
                    }
                }
            } else {
                expected.append("token válido");
            }

            String msg = "Erro sintático na linha " + line + ", coluna " + col +
                         ": encontrado '" + found + "'. Esperado: " + expected.toString();
            Linguagem20252.parseErrors.add(msg);
            System.err.println(msg);
        }

    public static void main(String[] args) {
        try {
            clearParseErrors();
            Linguagem20252 parser = new Linguagem20252(System.in);
            parser.programa();

            if (!lexicalErrors.isEmpty()) {
                System.out.println("Foram encontrados erros léxicos:");
                for (String msg : lexicalErrors) System.out.println("  - " + msg);
            } else if (!parseErrors.isEmpty()) {
                System.out.println("Foram encontrados erros sintáticos:");
                printParseErrors();
            } else {
                System.out.println("Programa compilado com sucesso.");
            }

        } catch (ParseException e) {
            System.err.println("Erro sintático: " + e.getMessage());
        } catch (TokenMgrError tme) {
            System.err.println("Erro léxico fatal: " + tme.getMessage());
        } catch (Exception ex) {
            System.err.println("Erro inesperado: " + ex.getMessage());
            ex.printStackTrace(System.err);
        }
    }
}

PARSER_END(Linguagem20252)

TOKEN_MGR_DECLS : {
    public void LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn,
                             String errorAfter, char curChar) {
        String message;
        if (EOFSeen) {
            message = "Erro léxico no fim do arquivo após \"" + errorAfter + "\".";
        } else {
            message = "Erro léxico na linha " + errorLine + ", coluna " + errorColumn +
                       ": caractere inesperado '" + curChar + "'";
        }
        Linguagem20252.lexicalErrors.add(message);
    }
}


TOKEN :
{
  // Palavras Reservadas
  < BEGIN: "begin" >
| < DEFINE: "define" >
| < START: "start" >
| < END: "end" >
| < NUM: "num" >
| < REAL: "real" >
| < TEXT: "text" >
| < FLAG: "flag" >
| < SET: "set" >
| < READ: "read" >
| < SHOW: "show" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < TRUE: "true" >
| < FALSE: "false" >
| < LOOP: "loop" >
| < WHILE: "while" >

  // Símbolos Especiais
| < ATRIBUICAO: "=" >
| < PONTO: "." >
| < DOIS_PONTOS: ":" >
| < PONTO_E_VIRGULA: ";" >
| < VIRGULA: "," >
| < ABRE_PARENTESES: "(" >
| < FECHA_PARENTESES: ")" >
| < ABRE_COLCHETES: "[" >
| < FECHA_COLCHETES: "]" >
| < ABRE_CHAVES: "{" >
| < FECHA_CHAVES: "}" >
| < MAIS: "+" >
| < MENOS: "-" >
| < VEZES: "*" >
| < DIVIDIR: "/" >
| < POTENCIA: "**" >
| < DIVISAO_INTEIRA: "%" >
| < RESTO_DIVISAO: "%%" >
| < IGUAL: "==" >
| < DIFERENTE: "!=" >
| < MENOR_OU_IGUAL: "<<=" >
| < MAIOR_OU_IGUAL: ">>=" >
| < MENOR: "<<" >
| < MAIOR: ">>" >
| < E: "&" >
| < OU: "|" >
| < NAO: "!" >

  // Identificadores e Constantes
| < IDENTIFICADOR: ( <LETRA> | "_" ) ( <LETRA> | <DIGITO> | "_" )* >
| < CONSTANTE_INTEIRA: (<DIGITO>)+ >
| < CONSTANTE_REAL: (<DIGITO>)+ "." (<DIGITO>)+ >
| < CONSTANTE_LITERAL:
        "\"" (~["\"","\n","\r"])* "\""
      | "'"  (~["'","\n","\r"])* "'"
  >
| < CONSTANTE_LOGICA: ( "true" | "false" ) >

  // Tokens auxiliares
| < #LETRA: [ "A"-"Z", "a"-"z" ] >
| < #DIGITO: [ "0"-"9" ] >
| < #ASCII: ~["\u0000" - "\u001F", "\u007F"] >
}

SKIP :
{
  < ESPACO_BRANCO: ( " " | "\t" | "\n" | "\r" )+ >
| < COMENTARIO_LINHA: ("//"(<ASCII>)*) >
| < COMENTARIO_BLOCO: ("/*"(<ASCII> | "\n")* "*/") >
}

// ERROS LÉXICOS

TOKEN :{
  < CONST_INT_INVALIDA: (<DIGITO><DIGITO><DIGITO>(<DIGITO>)+)>
| < CONST_REAL_INVALIDA:
      (<DIGITO>)+ "." (<DIGITO>)* ("." (<DIGITO>)+)+ >
| < IDENTIFICADOR_INVALIDO:
      ( <DIGITO> ( <LETRA> | <DIGITO> | "_" )* ) >
| < COMENTARIO_NAO_FECHADO: "/*" (~[])* >
| < LITERAL_NAO_FECHADO:
          "\"" (~["\"","\n","\r"])* ("\n" | "\r" | "\r\n")
        | "'"  (~["'","\n","\r"])* ("\n" | "\r" | "\r\n")
    >
| < SIMBOLO_INVALIDO: ~[] >
}

// Sintatico e lexico
void programa() : {}
{
  try {
    <BEGIN>
    identificador_programa()
    declaracao()
    <START>
    lista_de_comandos()
    { Semantico.P2(); }
    <END> <PONTO> <EOF>
  } catch (ParseException e) {
    reportParseError(e);
    skipUntil(new int[] {
        Linguagem20252Constants.END,
        Linguagem20252Constants.PONTO
    });
  }
}

void identificador_programa() : { Token id; } {
  ( id=<IDENTIFICADOR> { Semantico.P1(id.image); } )?
}


void declaracao() : {}
{
  try {
    ( <DEFINE> { Semantico.D0(); } lista_de_declaracao() )?
  } catch (ParseException e) {
    reportParseError(e);
    skipUntil(new int[] {
        Linguagem20252Constants.START,
        Linguagem20252Constants.END
    });
  }
}

void lista_de_declaracao() : {} {
  declaracao_variaveis() lista_de_declaracao_prim()
}

void lista_de_declaracao_prim() : {} {
  ( declaracao_variaveis() lista_de_declaracao_prim() )?
}

void declaracao_variaveis() : {}
{
  lista_de_identificadores()
  <DOIS_PONTOS>
  tipo()
  decl_do_vetor()
  <PONTO_E_VIRGULA>
  { Semantico.D6(); }
}

void lista_de_identificadores() : { Token id; } {
  id=<IDENTIFICADOR> { Semantico.D1(id.image); }
  lista_de_identificadores_prim()
}

void lista_de_identificadores_prim() : { Token id; } {
  ( <VIRGULA> id=<IDENTIFICADOR> { Semantico.D1(id.image); } lista_de_identificadores_prim() )?
}

void tipo() : {} {
   <NUM>  { Semantico.T(1); }
  | <REAL> { Semantico.T(2); }
  | <TEXT> { Semantico.T(3); }
  | <FLAG> { Semantico.T(4); }
}

void decl_do_vetor() : { Token c; } {
   <ABRE_COLCHETES> c=<CONSTANTE_INTEIRA>
       { Semantico.V1(Integer.parseInt(c.image)); }
       <FECHA_COLCHETES>
       inic_vetor()
       { Semantico.V2(); }

 | inic_escalar()
       { Semantico.E2(); Semantico.IE(); }
}

void inic_vetor() : {} {
  ( <ATRIBUICAO> <ABRE_CHAVES> lista_valores_vetor() <FECHA_CHAVES> { Semantico.IV_End(); } )?
}

void inic_escalar() : {} {
  ( <ATRIBUICAO> valor())?
}

void lista_valores_vetor() : {} {
  valor() { Semantico.VAL(); } lista_valores_vetor_prim()
}

void lista_valores_vetor_prim() : {} {
  ( <VIRGULA> valor() { Semantico.VAL(); } lista_valores_vetor_prim() )?
}

void valor() : { Token t; } {

    (t=<CONSTANTE_INTEIRA> { Semantico.C1(Integer.parseInt(t.image)); })
  | (t=<CONSTANTE_REAL> { Semantico.C2(Double.parseDouble(t.image)); })
  | (t=<CONSTANTE_LITERAL> { Semantico.C3(t.image); })
  | <TRUE>  { Semantico.C4(); }
  | <FALSE> { Semantico.C5(); }

}

void lista_de_comandos() : {}
{
  try {
    comando() lista_de_comandos_prim()
  } catch (ParseException e) {
    reportParseError(e);
    skipUntil(new int[] {
        Linguagem20252Constants.END,
        Linguagem20252Constants.ELSE,
        Linguagem20252Constants.PONTO_E_VIRGULA
    });
  }
}

void lista_de_comandos_prim() : {} {
  ( comando() lista_de_comandos_prim() )?
}

void comando() : {}
{
  try {
    atribuicao() | entrada() | saida() | selecao() | repeticao()
  } catch (ParseException e) {
    reportParseError(e);
    skipUntil(new int[] {
        Linguagem20252Constants.PONTO_E_VIRGULA,
        Linguagem20252Constants.END,
        Linguagem20252Constants.ELSE
    });
  }
}

void atribuicao() : { Token id; }
{
  try {
    <SET> id=<IDENTIFICADOR> { Semantico.A1(id.image); }
    indice() { Semantico.A2(); }
    <ATRIBUICAO>
    expressao() { Semantico.A3(); }
    <PONTO_E_VIRGULA>
  } catch (ParseException e) {
    reportParseError(e);
    skipUntil(new int[] {
        Linguagem20252Constants.PONTO_E_VIRGULA
    });
  }
}

void indice() : {} {
  ( <ABRE_COLCHETES> expressao() { Semantico.I1(); } <FECHA_COLCHETES> )?
}

void entrada() : { Token id; } {
  <READ> <ABRE_PARENTESES>
  id=<IDENTIFICADOR> { Semantico.R1(id.image); }
  ( <ABRE_COLCHETES> expressao() { Semantico.R2(); } <FECHA_COLCHETES> )?
  <FECHA_PARENTESES> <PONTO_E_VIRGULA>
  { Semantico.R_Generate(); }
}

void saida() : {} {
  <SHOW> <ABRE_PARENTESES>
  lista_de_saida()
  <FECHA_PARENTESES> <PONTO_E_VIRGULA>
}

void lista_de_saida() : {} {
  item() lista_de_saida_prim()
}

void lista_de_saida_prim() : {} {
  ( <VIRGULA> item() lista_de_saida_prim() )?
}

void item() : { Token id; Token t; } {

    id=<IDENTIFICADOR> { Semantico.S2(id.image); }
    ( <ABRE_COLCHETES> expressao() { Semantico.S3(); } <FECHA_COLCHETES> )?
    { Semantico.S_Generate(); }
  |
    (t=<CONSTANTE_INTEIRA> { Semantico.K1(Integer.parseInt(t.image)); })
  |
    (t=<CONSTANTE_REAL> { Semantico.K2(Double.parseDouble(t.image)); })
  |
    (t=<CONSTANTE_LITERAL> { Semantico.K3(t.image); })

}

void selecao() : {} {
  <IF> expressao() { Semantico.F1(); }
  <THEN>
  lista_de_comandos()
  ( <ELSE> { Semantico.F2(); } lista_de_comandos() )?
  <END> <PONTO_E_VIRGULA>
  { Semantico.F3(); }
}

void repeticao() : {} {
  <LOOP> <WHILE> expressao() { Semantico.L1(); }
  lista_de_comandos() { Semantico.L2(); }
  <END> <PONTO_E_VIRGULA>
}

void expressao() : {} {
  expressao_arit_logica() expressao_relacional()
}

void expressao_relacional() : {} {
  ( <IGUAL> expressao_arit_logica() { Semantico.REQ(); }
  | <DIFERENTE> expressao_arit_logica() { Semantico.RNEQ(); }
  | <MENOR> expressao_arit_logica() { Semantico.RLT(); }
  | <MAIOR> expressao_arit_logica() { Semantico.RGT(); }
  | <MENOR_OU_IGUAL> expressao_arit_logica() { Semantico.RLE(); }
  | <MAIOR_OU_IGUAL> expressao_arit_logica() { Semantico.RGE(); }
  )?
}

void expressao_arit_logica() : {} {
  termo2() menor_prioridade()
}

void menor_prioridade() : {} {
  ( <MAIS> termo2() { Semantico.ADD(); } menor_prioridade()
  | <MENOS> termo2() { Semantico.SUB(); } menor_prioridade()
  | <OU> termo2() { Semantico.OR(); } menor_prioridade()
  )?
}

void termo2() : {} {
  termo1() media_prioridade()
}

void media_prioridade() : {} {
  ( <VEZES> termo1() { Semantico.MUL(); } media_prioridade()
  | <DIVIDIR> termo1() { Semantico.DIV(); } media_prioridade()
  | <DIVISAO_INTEIRA> termo1() { Semantico.MOD(); } media_prioridade()
  | <RESTO_DIVISAO> termo1() { Semantico.REM(); } media_prioridade()
  | <E> termo1() { Semantico.AND(); } media_prioridade()
  )?
}

void termo1() : {} {
  elemento() maior_prioridade()
}

void maior_prioridade() : {} {
  ( <POTENCIA> elemento() { Semantico.POW(); } maior_prioridade() )?
}

void elemento() : { Token id; Token t; } {

    id=<IDENTIFICADOR> { Semantico.E1(id.image); }
    ( <ABRE_COLCHETES> expressao() { Semantico.E2_Indice(); } <FECHA_COLCHETES> )?
    { Semantico.E_Generate(); }
    /*id=<IDENTIFICADOR> { Semantico.E1(id.image); }
        ( <ABRE_COLCHETES> expressao() <FECHA_COLCHETES> )?*/
  |
    (t=<CONSTANTE_INTEIRA> { Semantico.C1(Integer.parseInt(t.image)); })
  |
    (t=<CONSTANTE_REAL> { Semantico.C2(Double.parseDouble(t.image)); })
  |
    (t=<CONSTANTE_LITERAL> { Semantico.C3(t.image); })
  |
    <TRUE> { Semantico.C4(); }
  |
    <FALSE> { Semantico.C5(); }
  |
    <ABRE_PARENTESES> expressao() <FECHA_PARENTESES>
  |
    <NAO> <ABRE_PARENTESES> expressao() <FECHA_PARENTESES> { Semantico.NOT(); }

}

// RECUPERAÇÃO DE ERROS

void skipUntil(int[] syncTokens) :
{ Token t; }
{
  {
    while (true) {
      t = getToken(1);
      if (t == null || t.kind == 0) return;
      boolean ok = false;
      for (int i=0; i<syncTokens.length; i++) {
        if (t.kind == syncTokens[i]) { ok = true; break; }
      }
      if (ok) return;
      getNextToken();
    }
  }
}
